<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.543">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>BCB-Quarto Blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">BCB-Quarto Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>首先，我需要写一段Preamble。在作业中对该段落的要求如下：</p>
<p>Write a brief paragraph describing the primary question or purpose of the post. Ideally, the concept should be challenging enough that it requires at least two visualizations that use different idioms (ie. don’t just make two scatterplots with different variables). The concept should also be challenging enough that it captures the interest of the reader (i.e.&nbsp;a plot of height and weight that shows they are correlated is trivial and not appropriate). The best approach is to explore a topic or question in which YOU are very interested.</p>
<p>现在，请你针对这一要求，修改以下的Introduction部分，使其符合要求。注意保留参考文献的引用。词数控制在300词左右：</p>
<p><strong><em>*Introduction*</em></strong></p>
<p>Wheat (<strong>Triticum aestivum</strong> L.) is one of the most important cereal crops worldwide, providing around 20% of the global caloric intake (Shiferaw et al.&nbsp;2013). However, both natural and anthropogenic factors are posing significant threats to global food security. An analysis of wheat breeding data in North America from 1960 to 2018 suggests that the current pace of variety improvement may not be sufficient to keep up with the negative impacts of climate change on wheat production (Zhang et al.&nbsp;2022). Furthermore, the Ukraine-Russia war in 2022 has disrupted one-third of the global wheat exports, which is likely to have severe repercussions on global food security for months, if not years, to come (Bentley et al.&nbsp;2022). Given these challenges, enhancing wheat yield remains a critical priority in wheat breeding efforts to ensure sustainable food production and global food security.</p>
<p>Yield is a complex trait influenced by multiple factors; therefore, identifying and targeting important yield-related traits is crucial for yield improvement (Isham et al.&nbsp;2021). Yield components, such as spikelet number per spike and thousand kernel weight, typically show higher heritability than grain yield itself (Wang et al.&nbsp;2018; Zhang et al.&nbsp;2018). Plant height is another key trait closely associated with plant architecture, lodging resistance, and yield performance (Wang et al.&nbsp;2017b). Additionally, heading date can significantly influence wheat adaptability to different environments, thus affecting yield (Chen et al.&nbsp;2022). Therefore, a comprehensive understanding of yield and yield-related traits and their genetic basis is essential for developing high-yielding wheat varieties through targeted breeding efforts.</p>
<p>Despite the importance of these traits, their phenotypic evaluation can be time-consuming and labor-intensive. Currently, traditional breeding methods, such as hybridization and phenotypic selection, remain essential components of wheat breeding programs (Ahmar et al.&nbsp;2020a). However, these approaches have several limitations. Firstly, field trials require substantial resources, including land, labor, and time, often taking up to 10-20 years to develop new varieties. Secondly, phenotypic data collection faces challenges such as the need for large-scale manual measurements, potential subjectivity in assessments, and the influence of environmental factors (Ahmar et al.&nbsp;2020b; Cha et al.&nbsp;2023). These limitations highlight the need for more efficient and cost-effective approaches to accelerate the wheat breeding process and improve the accuracy of trait evaluation.</p>
<p>The rapid advancement of low-cost, high-throughput genotyping technologies has provided wheat breeders with an abundance of molecular markers spanning the entire genome, facilitating the development of genomic selection (GS) as a promising tool to address the limitations of traditional breeding methods. GS utilizes genome-wide markers to capture the genetic relationships among individuals, enabling the evaluation of complex traits controlled by multiple genes (Zhang et al.&nbsp;2007). The GS process typically involves a reference population and a breeding population. First, phenotypic and genotypic data from the reference population are used to train a prediction model. Subsequently, the trained model and genotypic data of the breeding population are employed to calculate the genomic estimated breeding values (GEBVs) for the individuals in the breeding population(Larkin et al.&nbsp;2019). Finally, individuals within the breeding population can be determined using GEBVs, even in the absence of phenotypic information(Xu et al.&nbsp;2020). Heffner et al.&nbsp;(2009) highlighted that GS has the potential to accelerate breeding cycles, increase genetic gain per unit time, and significantly improve the efficiency of breeding programs by reducing the reliance on extensive phenotyping.</p>
<p>Several factors can influence the prediction accuracy of GS models, including population structure, training population size, and the choice of prediction models (Plavšin et al.&nbsp;2021). Selecting an appropriate prediction model is a relatively straightforward approach to improve prediction accuracy among these factors. GS models encompass both parametric methods (e.g., Ridge Regression) and non-parametric methods (e.g., Reproducing Kernel Hilbert Space and Random Forest), which differ in their assumptions and handling of marker effects (Desta and Ortiz 2014). In theory, non-parametric methods, which account for non-additive marker effects, should outperform parametric methods. However, the reality is more complex. For instance, Joshi et al.&nbsp;(2024) found that Ridge Regression best explained the variability in the phenotypic expression when predicting test weight in wheat. In another study, Ali et al.&nbsp;(2020) investigated the prediction of grain yield and five other yield-related traits in wheat, including spike number per square meter, thousand kernel weight, spike length, heading date, and plant height. They discovered that the best-performing model varied for each trait. These findings underscore the importance of evaluating and comparing different GS models for specific traits and datasets to identify the most suitable approach. Further research is needed to explore optimal models that maximize prediction ability and computational efficiency across a wide range of traits and datasets.</p>
<p>GS has been successfully applied in wheat breeding for various objectives, including yield improvement, disease resistance, and quality traits, and has even been explored for the domestication of new crops (Rasheed and Xia 2019). However, studies focusing on the application of GS for predicting yield and yield-related traits in wheat, particularly in spring wheat, are still limited. Therefore, further investigations are needed to assess the potential of GS in improving these economically important traits.</p>
<p>The present study aims to assess the genomic prediction accuracy of different models, including parametric and semi-parametric approaches, in predicting plant height (PHT), total spikelet number per spike (tSNS), heading date (HD), thousand kernel weight (TKW), and yield (YLD) in spring wheat. Six statistical models, namely Ridge Regression (RR), Reproducing Kernel Hilbert Space (RKHS), Genomic Best Linear Unbiased Prediction (GBLUP), Least Absolute Shrinkage and Selection Operator (LASSO), Support Vector Machine (SVM), and Random Forest (RF), were evaluated to identify the optimal model for each trait. The study was conducted using a diverse panel of 250 spring wheat lines, encompassing three market classes (soft white spring, hard white spring, and hard red spring) By leveraging the power of genomic prediction and utilizing a diverse spring wheat population evaluated in multiple environments, this research aims to facilitate precise breeding for improved yield and yield-related traits in spring wheat.</p>
<p>要求：</p>
<p>Data</p>
<p>Write a summary of the data sources you will use. Include a <code>Data Dictionary</code> table that fully describes each individual data file used. You may use your own research data or publicly available data from any source you like (with attribution). There aren’t any minimum or maximum data set size requirements, other than you need something big enough to be interesting and not so big that we don’t have a supercomputer capable of creating your visualization.</p>
<p>相关的资料如下：</p>
<p>Plant Material</p>
<p>This study selected 250 spring wheat varieties and elite lines (Supplemental Table 1). This collection was developed by breeding programs in the Northwestern Pacific region of the United States and the International Maize and Wheat Improvement Center (CIMMYT, Mexico City, Mexico). It encompasses three market categories of spring wheat cultivated in the Americas: soft white spring, hard white spring, and hard red spring, with the majority of the lines (&gt;50%) serving as founding lines for variety development programs in the region.</p>
<p>Phenotypic Evaluation</p>
<p>The panel was evaluated across five environments, designated as E1 to E5, with each year considered a distinct environment (E1 = 2016, E2 = 2017, E3 = 2021, E4 = 2022, E5 = 2023). The field trials were conducted at Aberdeen, Idaho located at 42°56’36” N and 112°50’22” W. The field design was a randomized complete block with two replicates. Each genotype was planted in 3.0 m plots consisting of seven rows, with a row spacing of 21 cm.</p>
<p>Yield per acre (YLD) in kilograms per hectare (kg/ha) was evaluated in four trials (E1, E2, E4, E5).</p>
<p>Genotyping</p>
<p>The population was genotyped using Illumina’s 90K iSelect SNPchip. Raw data was provided by the USDA/ARS Cereal Crops Research Unit and was analyzed using Genome Studio v2.0.5(Illumina 2010) for processing its raw data. Polymorphic markers were identified as exhibiting clear, distinct clusters in Genome Studio, with a minimum distance of 0.20 between the polar coordinates of normalized theta intensities. Markers were further filtered based on missing data (&gt;10%) and minor allele frequency (&lt;5%) using TASSEL v5.2.89 (Bradbury et al.&nbsp;2007).</p>
<p>我的文件储存在YLD.csv文件中</p>
<p>另外，这是一个.qmd文件。请问要求中的<code>Data Dictionary</code> table 是不是需要特殊设置呢？</p>
<section id="data-dictionary" class="level3">
<h3 class="anchored" data-anchor-id="data-dictionary">Data Dictionary</h3>
<table class="table">
<colgroup>
<col style="width: 11%">
<col style="width: 76%">
<col style="width: 11%">
</colgroup>
<thead>
<tr class="header">
<th>Field</th>
<th>Description</th>
<th>Data Type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ENT</td>
<td>Unique identifier for each wheat variety, numbered from 52001 to 52250</td>
<td>Integer</td>
</tr>
<tr class="even">
<td>Source</td>
<td>Source of the plant material, including universities (UI, UCD, WSU), CIMMYT, MSU, USDA, and other sources (commercial varieties and international germplasm)</td>
<td>String</td>
</tr>
<tr class="odd">
<td>YLD_E1</td>
<td>Yield in kilograms per hectare for environment E1 (2016)</td>
<td>Float</td>
</tr>
<tr class="even">
<td>YLD_E2</td>
<td>Yield in kilograms per hectare for environment E2 (2017)</td>
<td>Float</td>
</tr>
<tr class="odd">
<td>YLD_E4</td>
<td>Yield in kilograms per hectare for environment E4 (2022)</td>
<td>Float</td>
</tr>
<tr class="even">
<td>YLD_E5</td>
<td>Yield in kilograms per hectare for environment E5 (2023)</td>
<td>Float</td>
</tr>
<tr class="odd">
<td>YLD_BLUPs</td>
<td>Best Linear Unbiased Prediction (BLUP) values for yield, calculated from the yields of environments E1, E2, E4, and E5. NA indicates not applicable.</td>
<td>Float</td>
</tr>
</tbody>
</table>
<table class="table">
<thead>
<tr class="header">
<th>Df</th>
<th>Sum Sq</th>
<th>Mean Sq</th>
<th>F value</th>
<th>Pr(&gt;F)</th>
<th>R<sup>2</sup></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>6</td>
<td>1383462.467</td>
<td>230577.0778</td>
<td>5.068379905</td>
<td>6.41E-05</td>
<td>11.1%</td>
</tr>
<tr class="even">
<td>242</td>
<td>11009366.68</td>
<td>45493.25073</td>
<td>NA</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<table class="table">
<colgroup>
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 11%">
<col style="width: 33%">
<col style="width: 11%">
<col style="width: 7%">
<col style="width: 11%">
<col style="width: 11%">
</colgroup>
<thead>
<tr class="header">
<th>Trait</th>
<th>Env</th>
<th>Mean</th>
<th>Range</th>
<th>IQR</th>
<th>CV</th>
<th>Skewness</th>
<th>Kurtosis</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>YLD</td>
<td>E1</td>
<td>5687.207</td>
<td>3560.188-7753.867±839.68</td>
<td>1115.165</td>
<td>0.148</td>
<td>-0.258</td>
<td>-0.285</td>
</tr>
<tr class="even">
<td></td>
<td>E2</td>
<td>5528.63</td>
<td>4850.76-6181.51±272.1</td>
<td>356.24</td>
<td>0.05</td>
<td>-0.18</td>
<td>-0.22</td>
</tr>
<tr class="odd">
<td></td>
<td>E4</td>
<td>6012.449</td>
<td>5512.441-6517.149±178.2</td>
<td>216.375</td>
<td>0.03</td>
<td>-0.017</td>
<td>0.31</td>
</tr>
<tr class="even">
<td></td>
<td>E5</td>
<td>6630.67</td>
<td>5603.001-7432.273±327.87</td>
<td>428.973</td>
<td>0.049</td>
<td>-0.243</td>
<td>-0.11</td>
</tr>
<tr class="odd">
<td></td>
<td>BLUPs</td>
<td>6023.156</td>
<td>5340.134-6550.368±223.86</td>
<td>290.7</td>
<td>0.037</td>
<td>-0.292</td>
<td>-0.122</td>
</tr>
</tbody>
</table>
<table class="table">
<colgroup>
<col style="width: 8%">
<col style="width: 28%">
<col style="width: 31%">
<col style="width: 31%">
</colgroup>
<thead>
<tr class="header">
<th>Traits</th>
<th>Training Environments</th>
<th>Prediction Environments</th>
<th>Prediction accuracies a</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>YLD</td>
<td>BLUPs</td>
<td>BLUPs</td>
<td>0.424</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td>E1</td>
<td>0.369</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td>E2</td>
<td>0.325</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td>E4</td>
<td>0.189</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td>E5</td>
<td>0.240</td>
</tr>
<tr class="even">
<td>YLD</td>
<td>E1</td>
<td>BLUPs</td>
<td>0.288</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td>E1</td>
<td>0.565</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td>E2</td>
<td>0.277</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td>E4</td>
<td>0.109</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td>E5</td>
<td>-0.052</td>
</tr>
<tr class="odd">
<td>YLD</td>
<td>E2</td>
<td>BLUPs</td>
<td>0.319</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td>E1</td>
<td>0.343</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td>E2</td>
<td>0.360</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td>E4</td>
<td>0.140</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td>E5</td>
<td>0.041</td>
</tr>
<tr class="even">
<td>YLD</td>
<td>E4</td>
<td>BLUPs</td>
<td>0.161</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td>E1</td>
<td>0.242</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td>E2</td>
<td>0.129</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td>E4</td>
<td>0.078</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td>E5</td>
<td>0.058</td>
</tr>
<tr class="odd">
<td>YLD</td>
<td>E5</td>
<td>BLUPs</td>
<td>0.259</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td>E1</td>
<td>0.024</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td>E2</td>
<td>0.053</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td>E4</td>
<td>0.127</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td>E5</td>
<td>0.395</td>
</tr>
</tbody>
</table>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>